/*
 * generated by Xtext 2.25.0
 */
package edu.upb.lp.isc.generator

import edu.upb.lp.isc.pole.AsignacionVariable
import edu.upb.lp.isc.pole.CaseSwitch
import edu.upb.lp.isc.pole.Condicional
import edu.upb.lp.isc.pole.CondicionalElseIf
import edu.upb.lp.isc.pole.DeclVariables
import edu.upb.lp.isc.pole.Division
import edu.upb.lp.isc.pole.DoWhile
import edu.upb.lp.isc.pole.Ejecucion
import edu.upb.lp.isc.pole.ExpresionBooleanaSimple
import edu.upb.lp.isc.pole.ExpresionConcatenacion
import edu.upb.lp.isc.pole.ExpresionLongitudString
import edu.upb.lp.isc.pole.ExpresionSimpleAritmetica
import edu.upb.lp.isc.pole.ExpresionSimpleString
import edu.upb.lp.isc.pole.ExpresionSimpleXokas
import edu.upb.lp.isc.pole.For
import edu.upb.lp.isc.pole.Funciones
import edu.upb.lp.isc.pole.Imprimir
import edu.upb.lp.isc.pole.LlamadoFuncion
import edu.upb.lp.isc.pole.LlamadoMetodo
import edu.upb.lp.isc.pole.LlamadoVariable
import edu.upb.lp.isc.pole.Modulo
import edu.upb.lp.isc.pole.Multiplicacion
import edu.upb.lp.isc.pole.OpNEG
import edu.upb.lp.isc.pole.OperacionesBooleanasDeComparacion
import edu.upb.lp.isc.pole.OperacionesBooleanasDeComparacionAritmetica
import edu.upb.lp.isc.pole.OperadoresLogicosBooleanos
import edu.upb.lp.isc.pole.Programa
import edu.upb.lp.isc.pole.Resta
import edu.upb.lp.isc.pole.Suma
import edu.upb.lp.isc.pole.Switch
import edu.upb.lp.isc.pole.While
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import edu.upb.lp.isc.pole.ExpresionStringVacio
import edu.upb.lp.isc.pole.ImprimirSinSaltoDeLinea

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class PoleGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(Greeting)
//				.map[name]
//				.join(', '))


		val program = resource.contents.get(0) as Programa
		fsa.generateFile(program.name + ".cpp", generate(program))
			
	}
	
	
	
	
	
	def generate(Programa p) '''
	
		#include <iostream>
		using namespace std;
		
		«FOR instr: p.ej.instr»«IF instr instanceof Funciones» «IF instr.tipoDeDato.equals("DALAS")» string «ELSEIF instr.tipoDeDato.equals("MRBEAST")»int 
		«ELSEIF instr.tipoDeDato.equals("XOKAS")»double «ELSEIF instr.tipoDeDato.equals("YINYANG")»bool
		«ELSEIF instr.tipoDeDato.equals("MICORAZON")»void «ENDIF»«instr.name»(«FOR iParam: instr.param»«IF iParam.equals(instr.param.get(instr.param.length-1))»«IF iParam.tipoDeDato.equals("DALAS")» string «ELSEIF iParam.tipoDeDato.equals("MRBEAST")»int 
			«ELSEIF iParam.tipoDeDato.equals("XOKAS")»double «ELSEIF iParam.tipoDeDato.equals("YINYANG")»bool
			«ENDIF»«iParam.name»«ELSE»«IF iParam.tipoDeDato.equals("DALAS")» string «ELSEIF iParam.tipoDeDato.equals("MRBEAST")»int 
				«ELSEIF iParam.tipoDeDato.equals("XOKAS")»double «ELSEIF iParam.tipoDeDato.equals("YINYANG")»bool
				«ENDIF»«iParam.name»,«ENDIF» «ENDFOR»); «ENDIF»«ENDFOR»
		
		«generate(p.ej)»
	
	'''
	
	dispatch def generate(Ejecucion ej) '''
		
		«FOR instr: ej.instr» «generate(instr)» «ENDFOR»
		
		
	'''
	
	dispatch def generate(Imprimir imp) '''
	
		cout<<«generate(imp.e)»<<«FOR expr: imp.e1»«generate(expr)» << «ENDFOR»endl; 
	
	
	'''
	
	dispatch def generate(ImprimirSinSaltoDeLinea imp) '''
	
		cout<<«generate(imp.e)»<<«FOR expr: imp.e1»«generate(expr)» << «ENDFOR»; 
	
	'''
	
	dispatch def generate(DeclVariables decl) ''' 
	
	«IF decl.tipoDeDato.equals("DALAS")» string «ELSEIF decl.tipoDeDato.equals("MRBEAST")»int 
	«ELSEIF decl.tipoDeDato.equals("XOKAS")»double «ELSEIF decl.tipoDeDato.equals("YINYANG")»bool
	«ENDIF»«decl.name» = «generate(decl.valor)»;
			
	
	
	'''
	
	
	
	dispatch def generate(AsignacionVariable asig) '''
	
	«asig.variable.name» = «generate(asig.valor)»; 
	
	'''
	
	
	dispatch def generate(Condicional cond) '''
	
		if(«generate(cond.expr)») {
			
			«FOR instrIn: cond.instr»«generate(instrIn)»«ENDFOR»
			
		}«IF !cond.casiTeam.empty»«FOR condElif: cond.casiTeam»«generate(condElif)»«ENDFOR»«ENDIF»
		«IF !cond.instrElse.empty»
		else {
			
			«FOR instrIn2: cond.instrElse»«generate(instrIn2)»«ENDFOR»
			
		}
	«ENDIF»
	
	'''
	
	dispatch def generate(CondicionalElseIf condelif) '''
	
		else if(«generate(condelif.exprELIF)») {
			
			«FOR instrIn: condelif.instrELIF»«generate(instrIn)»«ENDFOR»
			
		}
	
	
	'''
	
	dispatch def generate(Switch sw) '''
	
		switch(«generate(sw.^var)») {
			
			«FOR caser : sw.^case»«generate(caser)»«ENDFOR»
			
			
		}
	
	'''
	dispatch def generate(CaseSwitch caseS) '''
	
		case «generate(caseS.e)»:
		
			«FOR instrI:caseS.instr»«generate(instrI)»«ENDFOR»
			break;
	
	'''
	
	
	
	
	dispatch def generate(While wh) '''
	
		while(«generate(wh.expr)») {
			
			«FOR instrI: wh.instr»«generate(instrI)»«ENDFOR»	
			
		}
	
	
	'''
	
	dispatch def generate(DoWhile dw) '''
	
		do {
			«FOR instrI: dw.instr»«generate(instrI)»«ENDFOR» 
			
		}while(«generate(dw.expr)»); 
	
	'''
	
	dispatch def generate(For fr) '''
	
		for(«generate(fr.^var)» «generate(fr.expr)» ; «generate(fr.asig).toString.replace(';', '')») {
			
			
			«FOR instrI: fr.instr»«generate(instrI)»«ENDFOR»
			
			
		}
	
	'''
	
	dispatch def generate(Funciones func) '''
	
	«IF func.tipoDeDato.equals("DALAS")» string «ELSEIF func.tipoDeDato.equals("MRBEAST")»int 
		«ELSEIF func.tipoDeDato.equals("XOKAS")»double «ELSEIF func.tipoDeDato.equals("YINYANG")»bool
		«ELSEIF func.tipoDeDato.equals("MICORAZON")»void «ENDIF»«func.name»(«FOR iParam: func.param»«IF iParam.equals(func.param.get(func.param.length-1))»«IF iParam.tipoDeDato.equals("DALAS")» string «ELSEIF iParam.tipoDeDato.equals("MRBEAST")»int 
			«ELSEIF iParam.tipoDeDato.equals("XOKAS")»double «ELSEIF iParam.tipoDeDato.equals("YINYANG")»bool
			«ENDIF»«iParam.name»«ELSE»«IF iParam.tipoDeDato.equals("DALAS")» string «ELSEIF iParam.tipoDeDato.equals("MRBEAST")»int 
				«ELSEIF iParam.tipoDeDato.equals("XOKAS")»double «ELSEIF iParam.tipoDeDato.equals("YINYANG")»bool
				«ENDIF»«iParam.name»,«ENDIF» «ENDFOR») {
			
			«FOR instrI: func.instr»«generate(instrI)»«ENDFOR»
			
			«IF !func.tipoDeDato.equals("MICORAZON")» return «generate(func.e)»; «ENDIF»
			
		}
	
	'''
	
	dispatch def generate(LlamadoMetodo llamado) ''' 
	
		«llamado.method.name»(«FOR arg : llamado.args» «IF arg.equals(llamado.args.get(llamado.args.length-1))»«generate(arg)»«ELSE»«generate(arg)», «ENDIF» «ENDFOR»);
	
	'''
	
	
	dispatch def generate(ExpresionSimpleAritmetica expr) '''
	
		«expr.x»
	
	'''
	
	dispatch def generate(ExpresionSimpleString expr) '''
	
		"«expr.x»"
	
	'''
	
	dispatch def generate(ExpresionBooleanaSimple expr) '''
	
		«IF expr.x.equals("YIN")» true«ELSEIF expr.x.equals("YANG")»false«ENDIF»
		
	'''
	
	dispatch def generate(ExpresionSimpleXokas expr) '''
	
		«expr.x».«expr.y»«expr.z»
	
	'''
	
	dispatch def generate(ExpresionLongitudString expr) '''
	
		«generate(expr.llamado)».length()
	
	
	'''
	
	dispatch def generate(Suma suma) '''
	
		(«generate(suma.op.izq)» + «generate(suma.op.der)»)	
	
	'''
	
	dispatch def generate(Resta resta) '''
	
		(«generate(resta.op.izq)» - «generate(resta.op.der)»)
	
	'''
	
	dispatch def generate(Multiplicacion mul) '''
	
		(«generate(mul.op.izq)» * «generate(mul.op.der)»)
	
	'''
	
	dispatch def generate(Division div) '''
	
		(«generate(div.op.izq)» / «generate(div.op.der)»)
	
	'''
	
	dispatch def generate(Modulo mod) '''
	
		(«generate(mod.op.izq)» % «generate(mod.op.der)»)
	
	'''
	
	dispatch def generate(ExpresionConcatenacion conc)'''
	
		«generate(conc.primero)» + «generate(conc.segundo)»
	
	
	'''
	
	dispatch def generate(OpNEG o)'''
	
		!«generate(o.expr)»
	
	'''
	
	dispatch def generate(LlamadoVariable llamadoVariable) '''
	
		«llamadoVariable.variable.name»
	
	'''
	dispatch def generate(LlamadoFuncion llamadoFuncion) '''
	
		«llamadoFuncion.func.name»(«FOR arg : llamadoFuncion.args» «IF arg.equals(llamadoFuncion.args.get(llamadoFuncion.args.length-1))»«generate(arg)»«ELSE»«generate(arg)», «ENDIF» «ENDFOR»)
		
	'''
	
	dispatch def generate(OperadoresLogicosBooleanos op) '''
	
		«generate(op.izq)»«IF op.x.equals("PEPE")»&&«ELSEIF op.x.equals("NAR")»||«ELSEIF op.x.equals("XO")»^«ENDIF»«generate(op.der)»
	
	'''
	
	dispatch def generate(OperacionesBooleanasDeComparacion op) '''
	
		«generate(op.izq)»«IF op.x.equals("POXI")»==«ELSEIF op.x.equals("AGUA")» !=«ENDIF»«generate(op.der)»
	
	'''
	
	dispatch def generate(ExpresionStringVacio expr) '''
	
		«generate(expr.llamado)».empty()
	
	'''
	
	dispatch def generate(OperacionesBooleanasDeComparacionAritmetica expr) '''
	
		«generate(expr.op.izq)» «IF expr.x.equals("LEGAL")»>«ELSEIF expr.x.equals("ILEGAL")»<«ELSEIF expr.x.equals("ALEGAL")»>=«ELSEIF expr.x.equals("ANTILEGAL")»<=«ENDIF»«generate(expr.op.der)»
	
	'''
	

	
	
	
	
		
		
		
	
	
	
	
	
	
	
	
	
	
		
		
		
	
}
